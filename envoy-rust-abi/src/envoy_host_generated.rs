// This file is automatically generated, DO NOT EDIT
//
// To regenerate this file run the `crates/generate-raw` command (see https://github.com/bytecodealliance/wasi)

pub use crate::types_generated::*;

/// Configuration and Status.
/// extern "C" WasmResult proxy_get_configuration(const char** configuration_ptr,
///                                               size_t* configuration_size);
/// TODO(docs)
///
/// ## Parameters
///
/// * `config` - TODO(docs)
/// * `config_len` - TODO(docs)
///
/// ## Return
///
/// * `error` - TODO(docs)
pub unsafe fn proxy_get_configuration(config: *mut *mut u8, config_len: *mut Size) -> Result<()> {
    let rc = envoy::proxy_get_configuration(config, config_len);
    if let Some(err) = Error::from_raw_error(rc) {
        Err(err)
    } else {
        Ok(())
    }
}

/// extern "C" WasmResult proxy_get_status(uint32_t* status_code_ptr, const char** message_ptr,
///                                        size_t* message_size);
/// Results status details for any previous ABI call and onGrpcClose.
///
/// ## Parameters
///
/// * `code` - TODO(docs)
/// * `message` - TODO(docs)
/// * `message_len` - TODO(docs)
///
/// ## Return
///
/// * `error` - TODO(docs)
pub unsafe fn proxy_get_status(
    code: *mut WasmResult,
    message: *mut *mut u8,
    message_len: *mut Size,
) -> Result<()> {
    let rc = envoy::proxy_get_status(code, message, message_len);
    if let Some(err) = Error::from_raw_error(rc) {
        Err(err)
    } else {
        Ok(())
    }
}

/// Logging
/// extern "C" WasmResult proxy_log(LogLevel level, const char* logMessage, size_t messageSize);
/// TODO(docs)
///
/// ## Parameters
///
/// * `level` - TODO(docs)
/// * `message` - TODO(docs)
///
/// ## Return
///
/// * `error` - TODO(docs)
pub unsafe fn proxy_log(level: LogLevel, message: &str) -> Result<()> {
    let rc = envoy::proxy_log(level, message.as_ptr(), message.len());
    if let Some(err) = Error::from_raw_error(rc) {
        Err(err)
    } else {
        Ok(())
    }
}

/// Timer
/// extern "C" WasmResult proxy_set_tick_period_milliseconds(uint32_t millisecond);
/// Timer (must be called from a root context, e.g. onStart, onTick).
///
/// ## Parameters
///
/// * `period_millis` - TODO(docs)
///
/// ## Return
///
/// * `error` - TODO(docs)
pub unsafe fn proxy_set_tick_period_milliseconds(period_millis: u32) -> Result<()> {
    let rc = envoy::proxy_set_tick_period_milliseconds(period_millis);
    if let Some(err) = Error::from_raw_error(rc) {
        Err(err)
    } else {
        Ok(())
    }
}

/// Time
/// extern "C" WasmResult proxy_get_current_time_nanoseconds(uint64_t* nanoseconds);
/// TODO(docs)
///
/// ## Parameters
///
/// * `time` - TODO(docs)
///
/// ## Return
///
/// * `error` - TODO(docs)
pub unsafe fn proxy_get_current_time_nanoseconds(time: *mut Timestamp) -> Result<()> {
    let rc = envoy::proxy_get_current_time_nanoseconds(time);
    if let Some(err) = Error::from_raw_error(rc) {
        Err(err)
    } else {
        Ok(())
    }
}

/// State accessors
/// extern "C" WasmResult proxy_get_property(const char* path_ptr, size_t path_size,
///                                          const char** value_ptr_ptr, size_t* value_size_ptr);
/// TODO(docs)
///
/// ## Parameters
///
/// * `path` - TODO(docs)
/// * `value` - TODO(docs)
/// * `value_len` - TODO(docs)
///
/// ## Return
///
/// * `error` - TODO(docs)
pub unsafe fn proxy_get_property(
    path: &str,
    value: *mut *mut u8,
    value_len: *mut Size,
) -> Result<()> {
    let rc = envoy::proxy_get_property(path.as_ptr(), path.len(), value, value_len);
    if let Some(err) = Error::from_raw_error(rc) {
        Err(err)
    } else {
        Ok(())
    }
}

/// extern "C" WasmResult proxy_set_property(const char* path_ptr, size_t path_size,
///                                          const char* value_ptr, size_t value_size);
/// TODO(docs)
///
/// ## Parameters
///
/// * `path` - TODO(docs)
/// * `value` - TODO(docs)
///
/// ## Return
///
/// * `error` - TODO(docs)
pub unsafe fn proxy_set_property(path: &str, value: &str) -> Result<()> {
    let rc = envoy::proxy_set_property(path.as_ptr(), path.len(), value.as_ptr(), value.len());
    if let Some(err) = Error::from_raw_error(rc) {
        Err(err)
    } else {
        Ok(())
    }
}

/// System
/// extern "C" WasmResult proxy_set_effective_context(uint32_t effective_context_id);
/// TODO(docs)
///
/// ## Parameters
///
/// * `id` - TODO(docs)
///
/// ## Return
///
/// * `error` - TODO(docs)
pub unsafe fn proxy_set_effective_context(id: ContextId) -> Result<()> {
    let rc = envoy::proxy_set_effective_context(id);
    if let Some(err) = Error::from_raw_error(rc) {
        Err(err)
    } else {
        Ok(())
    }
}

/// extern "C" WasmResult proxy_done();
/// TODO(docs)
///
/// ## Return
///
/// * `error` - TODO(docs)
pub unsafe fn proxy_done() -> Result<()> {
    let rc = envoy::proxy_done();
    if let Some(err) = Error::from_raw_error(rc) {
        Err(err)
    } else {
        Ok(())
    }
}

/// Metrics
/// extern "C" WasmResult proxy_define_metric(MetricType type, const char* name_ptr, size_t name_size,
///                                           uint32_t* metric_id);
/// TODO(docs)
///
/// ## Parameters
///
/// * `metric_type` - TODO(docs)
/// * `name` - TODO(docs)
/// * `id` - TODO(docs)
///
/// ## Return
///
/// * `error` - TODO(docs)
pub unsafe fn proxy_define_metric(
    metric_type: MetricType,
    name: &str,
    id: *mut MetricId,
) -> Result<()> {
    let rc = envoy::proxy_define_metric(metric_type, name.as_ptr(), name.len(), id);
    if let Some(err) = Error::from_raw_error(rc) {
        Err(err)
    } else {
        Ok(())
    }
}

/// extern "C" WasmResult proxy_increment_metric(uint32_t metric_id, int64_t offset);
/// TODO(docs)
///
/// ## Parameters
///
/// * `id` - TODO(docs)
/// * `offset` - TODO(docs)
///
/// ## Return
///
/// * `error` - TODO(docs)
pub unsafe fn proxy_increment_metric(id: MetricId, offset: i64) -> Result<()> {
    let rc = envoy::proxy_increment_metric(id, offset);
    if let Some(err) = Error::from_raw_error(rc) {
        Err(err)
    } else {
        Ok(())
    }
}

/// extern "C" WasmResult proxy_record_metric(uint32_t metric_id, uint64_t value);
/// TODO(docs)
///
/// ## Parameters
///
/// * `id` - TODO(docs)
/// * `value` - TODO(docs)
///
/// ## Return
///
/// * `error` - TODO(docs)
pub unsafe fn proxy_record_metric(id: MetricId, value: u64) -> Result<()> {
    let rc = envoy::proxy_record_metric(id, value);
    if let Some(err) = Error::from_raw_error(rc) {
        Err(err)
    } else {
        Ok(())
    }
}

/// extern "C" WasmResult proxy_get_metric(uint32_t metric_id, uint64_t* result);
/// TODO(docs)
///
/// ## Parameters
///
/// * `id` - TODO(docs)
/// * `value` - TODO(docs)
///
/// ## Return
///
/// * `error` - TODO(docs)
pub unsafe fn proxy_get_metric(id: MetricId, value: *mut u64) -> Result<()> {
    let rc = envoy::proxy_get_metric(id, value);
    if let Some(err) = Error::from_raw_error(rc) {
        Err(err)
    } else {
        Ok(())
    }
}

/// Continue/Reply/Route
/// extern "C" WasmResult proxy_continue_request();
/// TODO(docs)
///
/// ## Return
///
/// * `error` - TODO(docs)
pub unsafe fn proxy_continue_request() -> Result<()> {
    let rc = envoy::proxy_continue_request();
    if let Some(err) = Error::from_raw_error(rc) {
        Err(err)
    } else {
        Ok(())
    }
}

/// extern "C" WasmResult proxy_continue_response();
/// TODO(docs)
///
/// ## Return
///
/// * `error` - TODO(docs)
pub unsafe fn proxy_continue_response() -> Result<()> {
    let rc = envoy::proxy_continue_response();
    if let Some(err) = Error::from_raw_error(rc) {
        Err(err)
    } else {
        Ok(())
    }
}

/// extern "C" WasmResult
/// proxy_send_local_response(uint32_t response_code, const char* response_code_details_ptr,
///                           size_t response_code_details_size, const char* body_ptr, size_t body_size,
///                           const char* additional_response_header_pairs_ptr,
///                           size_t additional_response_header_pairs_size, uint32_t grpc_status);
/// TODO(docs)
///
/// ## Parameters
///
/// * `response_code` - TODO(docs)
/// * `response_code_details` - TODO(docs)
/// * `body` - TODO(docs)
/// * `additional_response_header_pairs` - TODO(docs)
/// * `grpc_status` - TODO(docs)
///
/// ## Return
///
/// * `error` - TODO(docs)
pub unsafe fn proxy_send_local_response(
    response_code: u32,
    response_code_details: &str,
    body: &str,
    additional_response_header_pairs: &str,
    grpc_status: GrpcStatus,
) -> Result<()> {
    let rc = envoy::proxy_send_local_response(
        response_code,
        response_code_details.as_ptr(),
        response_code_details.len(),
        body.as_ptr(),
        body.len(),
        additional_response_header_pairs.as_ptr(),
        additional_response_header_pairs.len(),
        grpc_status,
    );
    if let Some(err) = Error::from_raw_error(rc) {
        Err(err)
    } else {
        Ok(())
    }
}

/// extern "C" WasmResult proxy_clear_route_cache();
/// TODO(docs)
///
/// ## Return
///
/// * `error` - TODO(docs)
pub unsafe fn proxy_clear_route_cache() -> Result<()> {
    let rc = envoy::proxy_clear_route_cache();
    if let Some(err) = Error::from_raw_error(rc) {
        Err(err)
    } else {
        Ok(())
    }
}

/// SharedData
/// extern "C" WasmResult proxy_get_shared_data(const char* key_ptr, size_t key_size,
///                                             const char** value_ptr, size_t* value_size,
///                                             uint32_t* cas);
/// Returns: Ok, NotFound
/// TODO(docs)
///
/// ## Parameters
///
/// * `key` - TODO(docs)
/// * `value` - TODO(docs)
/// * `value_len` - TODO(docs)
/// * `cas` - TODO(docs)
///
/// ## Return
///
/// * `error` - TODO(docs)
pub unsafe fn proxy_get_shared_data(
    key: &str,
    value: *mut *mut u8,
    value_len: *mut Size,
    cas: *mut u32,
) -> Result<()> {
    let rc = envoy::proxy_get_shared_data(key.as_ptr(), key.len(), value, value_len, cas);
    if let Some(err) = Error::from_raw_error(rc) {
        Err(err)
    } else {
        Ok(())
    }
}

/// extern "C" WasmResult proxy_set_shared_data(const char* key_ptr, size_t key_size,
///                                             const char* value_ptr, size_t value_size, uint32_t cas);
/// //  If cas != 0 and cas != the current cas for 'key' return false, otherwise set the value and
/// //  return true.
/// // Returns: Ok, CasMismatch
/// TODO(docs)
///
/// ## Parameters
///
/// * `key` - TODO(docs)
/// * `value` - TODO(docs)
/// * `cas` - TODO(docs)
///
/// ## Return
///
/// * `error` - TODO(docs)
pub unsafe fn proxy_set_shared_data(key: &str, value: &str, cas: u32) -> Result<()> {
    let rc =
        envoy::proxy_set_shared_data(key.as_ptr(), key.len(), value.as_ptr(), value.len(), cas);
    if let Some(err) = Error::from_raw_error(rc) {
        Err(err)
    } else {
        Ok(())
    }
}

/// SharedQueue
/// extern "C" WasmResult proxy_register_shared_queue(const char* queue_name_ptr,
///                                                   size_t queue_name_size, uint32_t* token);
/// // Note: Registering the same queue_name will overwrite the old registration while preseving any
/// // pending data. Consequently it should typically be followed by a call to
/// // proxy_dequeue_shared_queue. Returns: Ok
/// TODO(docs)
///
/// ## Parameters
///
/// * `queue_name` - TODO(docs)
/// * `token` - TODO(docs)
///
/// ## Return
///
/// * `error` - TODO(docs)
pub unsafe fn proxy_register_shared_queue(queue_name: &str, token: *mut Token) -> Result<()> {
    let rc = envoy::proxy_register_shared_queue(queue_name.as_ptr(), queue_name.len(), token);
    if let Some(err) = Error::from_raw_error(rc) {
        Err(err)
    } else {
        Ok(())
    }
}

/// extern "C" WasmResult proxy_resolve_shared_queue(const char* vm_id, size_t vm_id_size,
///                                                  const char* queue_name_ptr, size_t queue_name_size,
///                                                  uint32_t* token);
/// // Returns: Ok, NotFound
/// TODO(docs)
///
/// ## Parameters
///
/// * `vm_id` - TODO(docs)
/// * `queue_name` - TODO(docs)
/// * `token` - TODO(docs)
///
/// ## Return
///
/// * `error` - TODO(docs)
pub unsafe fn proxy_resolve_shared_queue(
    vm_id: &str,
    queue_name: &str,
    token: *mut Token,
) -> Result<()> {
    let rc = envoy::proxy_resolve_shared_queue(
        vm_id.as_ptr(),
        vm_id.len(),
        queue_name.as_ptr(),
        queue_name.len(),
        token,
    );
    if let Some(err) = Error::from_raw_error(rc) {
        Err(err)
    } else {
        Ok(())
    }
}

/// extern "C" WasmResult proxy_dequeue_shared_queue(uint32_t token, const char** data_ptr,
///                                                  size_t* data_size);
/// // Returns Ok, Empty, NotFound (token not registered).
/// TODO(docs)
///
/// ## Parameters
///
/// * `token` - TODO(docs)
/// * `data` - TODO(docs)
/// * `data_len` - TODO(docs)
///
/// ## Return
///
/// * `error` - TODO(docs)
pub unsafe fn proxy_dequeue_shared_queue(
    token: Token,
    data: *mut *mut u8,
    data_len: *mut Size,
) -> Result<()> {
    let rc = envoy::proxy_dequeue_shared_queue(token, data, data_len);
    if let Some(err) = Error::from_raw_error(rc) {
        Err(err)
    } else {
        Ok(())
    }
}

/// extern "C" WasmResult proxy_enqueue_shared_queue(uint32_t token, const char* data_ptr,
///                                                  size_t data_size);
/// // Returns false if the queue was not found and the data was not enqueued.
/// TODO(docs)
///
/// ## Parameters
///
/// * `token` - TODO(docs)
/// * `data` - TODO(docs)
///
/// ## Return
///
/// * `error` - TODO(docs)
pub unsafe fn proxy_enqueue_shared_queue(token: Token, data: &str) -> Result<()> {
    let rc = envoy::proxy_enqueue_shared_queue(token, data.as_ptr(), data.len());
    if let Some(err) = Error::from_raw_error(rc) {
        Err(err)
    } else {
        Ok(())
    }
}

/// Headers/Trailers/Metadata Maps
/// extern "C" WasmResult proxy_add_header_map_value(HeaderMapType type, const char* key_ptr,
///                                                  size_t key_size, const char* value_ptr,
///                                                  size_t value_size);
/// TODO(docs)
///
/// ## Parameters
///
/// * `headers_type` - TODO(docs)
/// * `key` - TODO(docs)
/// * `value` - TODO(docs)
///
/// ## Return
///
/// * `error` - TODO(docs)
pub unsafe fn proxy_add_header_map_value(
    headers_type: HeadersType,
    key: &str,
    value: &str,
) -> Result<()> {
    let rc = envoy::proxy_add_header_map_value(
        headers_type,
        key.as_ptr(),
        key.len(),
        value.as_ptr(),
        value.len(),
    );
    if let Some(err) = Error::from_raw_error(rc) {
        Err(err)
    } else {
        Ok(())
    }
}

/// extern "C" WasmResult proxy_get_header_map_value(HeaderMapType type, const char* key_ptr,
///                                                  size_t key_size, const char** value_ptr,
///                                                  size_t* value_size);
/// TODO(docs)
///
/// ## Parameters
///
/// * `headers_type` - TODO(docs)
/// * `key` - TODO(docs)
/// * `value` - TODO(docs)
/// * `value_len` - TODO(docs)
///
/// ## Return
///
/// * `error` - TODO(docs)
pub unsafe fn proxy_get_header_map_value(
    headers_type: HeadersType,
    key: &str,
    value: *mut *mut u8,
    value_len: *mut Size,
) -> Result<()> {
    let rc =
        envoy::proxy_get_header_map_value(headers_type, key.as_ptr(), key.len(), value, value_len);
    if let Some(err) = Error::from_raw_error(rc) {
        Err(err)
    } else {
        Ok(())
    }
}

/// extern "C" WasmResult proxy_get_header_map_pairs(HeaderMapType type, const char** ptr,
///                                                  size_t* size);
/// TODO(docs)
///
/// ## Parameters
///
/// * `headers_type` - TODO(docs)
/// * `buf` - TODO(docs)
/// * `buf_len` - TODO(docs)
///
/// ## Return
///
/// * `error` - TODO(docs)
pub unsafe fn proxy_get_header_map_pairs(
    headers_type: HeadersType,
    buf: *mut *mut u8,
    buf_len: *mut Size,
) -> Result<()> {
    let rc = envoy::proxy_get_header_map_pairs(headers_type, buf, buf_len);
    if let Some(err) = Error::from_raw_error(rc) {
        Err(err)
    } else {
        Ok(())
    }
}

/// extern "C" WasmResult proxy_set_header_map_pairs(HeaderMapType type, const char* ptr, size_t size);
/// TODO(docs)
///
/// ## Parameters
///
/// * `headers_type` - TODO(docs)
/// * `buf` - TODO(docs)
///
/// ## Return
///
/// * `error` - TODO(docs)
pub unsafe fn proxy_set_header_map_pairs(headers_type: HeadersType, buf: &str) -> Result<()> {
    let rc = envoy::proxy_set_header_map_pairs(headers_type, buf.as_ptr(), buf.len());
    if let Some(err) = Error::from_raw_error(rc) {
        Err(err)
    } else {
        Ok(())
    }
}

/// extern "C" WasmResult proxy_replace_header_map_value(HeaderMapType type, const char* key_ptr,
///                                                      size_t key_size, const char* value_ptr,
///                                                      size_t value_size);
/// TODO(docs)
///
/// ## Parameters
///
/// * `headers_type` - TODO(docs)
/// * `key` - TODO(docs)
/// * `value` - TODO(docs)
///
/// ## Return
///
/// * `error` - TODO(docs)
pub unsafe fn proxy_replace_header_map_value(
    headers_type: HeadersType,
    key: &str,
    value: &str,
) -> Result<()> {
    let rc = envoy::proxy_replace_header_map_value(
        headers_type,
        key.as_ptr(),
        key.len(),
        value.as_ptr(),
        value.len(),
    );
    if let Some(err) = Error::from_raw_error(rc) {
        Err(err)
    } else {
        Ok(())
    }
}

/// extern "C" WasmResult proxy_remove_header_map_value(HeaderMapType type, const char* key_ptr,
///                                                     size_t key_size);
/// TODO(docs)
///
/// ## Parameters
///
/// * `headers_type` - TODO(docs)
/// * `key` - TODO(docs)
///
/// ## Return
///
/// * `error` - TODO(docs)
pub unsafe fn proxy_remove_header_map_value(headers_type: HeadersType, key: &str) -> Result<()> {
    let rc = envoy::proxy_remove_header_map_value(headers_type, key.as_ptr(), key.len());
    if let Some(err) = Error::from_raw_error(rc) {
        Err(err)
    } else {
        Ok(())
    }
}

/// extern "C" WasmResult proxy_get_header_map_size(HeaderMapType type, size_t* size);
/// TODO(docs)
///
/// ## Parameters
///
/// * `headers_type` - TODO(docs)
/// * `len` - TODO(docs)
///
/// ## Return
///
/// * `error` - TODO(docs)
pub unsafe fn proxy_get_header_map_size(
    headers_type: HeadersType,
    len: *mut MapSize,
) -> Result<()> {
    let rc = envoy::proxy_get_header_map_size(headers_type, len);
    if let Some(err) = Error::from_raw_error(rc) {
        Err(err)
    } else {
        Ok(())
    }
}

/// Buffer
/// extern "C" WasmResult proxy_get_buffer_bytes(BufferType type, uint32_t start, uint32_t length,
///                                              const char** ptr, size_t* size);
/// TODO(docs)
///
/// ## Parameters
///
/// * `buffer_type` - TODO(docs)
/// * `start` - TODO(docs)
/// * `length` - TODO(docs)
/// * `buf` - TODO(docs)
/// * `buf_len` - TODO(docs)
///
/// ## Return
///
/// * `error` - TODO(docs)
pub unsafe fn proxy_get_buffer_bytes(
    buffer_type: BufferType,
    start: u32,
    length: u32,
    buf: *mut *mut u8,
    buf_len: *mut Size,
) -> Result<()> {
    let rc = envoy::proxy_get_buffer_bytes(buffer_type, start, length, buf, buf_len);
    if let Some(err) = Error::from_raw_error(rc) {
        Err(err)
    } else {
        Ok(())
    }
}

/// extern "C" WasmResult proxy_get_buffer_status(BufferType type, size_t* length_ptr,
///                                               uint32_t* flags_ptr);
/// TODO(docs)
///
/// ## Parameters
///
/// * `buffer_type` - TODO(docs)
/// * `len` - TODO(docs)
/// * `flags` - TODO(docs)
///
/// ## Return
///
/// * `error` - TODO(docs)
pub unsafe fn proxy_get_buffer_status(
    buffer_type: BufferType,
    len: *mut u32,
    flags: *mut BufferFlags,
) -> Result<()> {
    let rc = envoy::proxy_get_buffer_status(buffer_type, len, flags);
    if let Some(err) = Error::from_raw_error(rc) {
        Err(err)
    } else {
        Ok(())
    }
}

/// HTTP
/// extern "C" WasmResult proxy_http_call(const char* uri_ptr, size_t uri_size, void* header_pairs_ptr,
///                                       size_t header_pairs_size, const char* body_ptr,
///                                       size_t body_size, void* trailer_pairs_ptr,
///                                       size_t trailer_pairs_size, uint32_t timeout_milliseconds,
///                                       uint32_t* token_ptr);
/// TODO(docs)
///
/// ## Parameters
///
/// * `uri` - TODO(docs)
/// * `header_pairs` - TODO(docs)
/// * `body` - TODO(docs)
/// * `trailer_pairs` - TODO(docs)
/// * `timeout_ms` - TODO(docs)
/// * `token` - TODO(docs)
///
/// ## Return
///
/// * `error` - TODO(docs)
pub unsafe fn proxy_http_call(
    uri: &str,
    header_pairs: &str,
    body: &str,
    trailer_pairs: &str,
    timeout_ms: u32,
    token: *mut Token,
) -> Result<()> {
    let rc = envoy::proxy_http_call(
        uri.as_ptr(),
        uri.len(),
        header_pairs.as_ptr(),
        header_pairs.len(),
        body.as_ptr(),
        body.len(),
        trailer_pairs.as_ptr(),
        trailer_pairs.len(),
        timeout_ms,
        token,
    );
    if let Some(err) = Error::from_raw_error(rc) {
        Err(err)
    } else {
        Ok(())
    }
}

/// gRPC
/// extern "C" WasmResult proxy_grpc_call(const char* service_ptr, size_t service_size,
///                                       const char* service_name_ptr, size_t service_name_size,
///                                       const char* method_name_ptr, size_t method_name_size,
///                                       const char* request_ptr, size_t request_size,
///                                       uint32_t timeout_milliseconds, uint32_t* token_ptr);
/// TODO(docs)
///
/// ## Parameters
///
/// * `service` - TODO(docs)
/// * `service_name` - TODO(docs)
/// * `method_name` - TODO(docs)
/// * `request` - TODO(docs)
/// * `timeout_ms` - TODO(docs)
/// * `token` - TODO(docs)
///
/// ## Return
///
/// * `error` - TODO(docs)
pub unsafe fn proxy_grpc_call(
    service: &str,
    service_name: &str,
    method_name: &str,
    request: &str,
    timeout_ms: u32,
    token: *mut Token,
) -> Result<()> {
    let rc = envoy::proxy_grpc_call(
        service.as_ptr(),
        service.len(),
        service_name.as_ptr(),
        service_name.len(),
        method_name.as_ptr(),
        method_name.len(),
        request.as_ptr(),
        request.len(),
        timeout_ms,
        token,
    );
    if let Some(err) = Error::from_raw_error(rc) {
        Err(err)
    } else {
        Ok(())
    }
}

/// extern "C" WasmResult proxy_grpc_stream(const char* service_ptr, size_t service_size,
///                                         const char* service_name_ptr, size_t service_name_size,
///                                         const char* method_name_ptr, size_t method_name_size,
///                                         uint32_t* token_ptr);
/// TODO(docs)
///
/// ## Parameters
///
/// * `service` - TODO(docs)
/// * `service_name` - TODO(docs)
/// * `method_name` - TODO(docs)
/// * `token` - TODO(docs)
///
/// ## Return
///
/// * `error` - TODO(docs)
pub unsafe fn proxy_grpc_stream(
    service: &str,
    service_name: &str,
    method_name: &str,
    token: *mut Token,
) -> Result<()> {
    let rc = envoy::proxy_grpc_stream(
        service.as_ptr(),
        service.len(),
        service_name.as_ptr(),
        service_name.len(),
        method_name.as_ptr(),
        method_name.len(),
        token,
    );
    if let Some(err) = Error::from_raw_error(rc) {
        Err(err)
    } else {
        Ok(())
    }
}

/// extern "C" WasmResult proxy_grpc_cancel(uint32_t token);
/// TODO(docs)
///
/// ## Parameters
///
/// * `token` - TODO(docs)
///
/// ## Return
///
/// * `error` - TODO(docs)
pub unsafe fn proxy_grpc_cancel(token: Token) -> Result<()> {
    let rc = envoy::proxy_grpc_cancel(token);
    if let Some(err) = Error::from_raw_error(rc) {
        Err(err)
    } else {
        Ok(())
    }
}

/// extern "C" WasmResult proxy_grpc_close(uint32_t token);
/// TODO(docs)
///
/// ## Parameters
///
/// * `token` - TODO(docs)
///
/// ## Return
///
/// * `error` - TODO(docs)
pub unsafe fn proxy_grpc_close(token: Token) -> Result<()> {
    let rc = envoy::proxy_grpc_close(token);
    if let Some(err) = Error::from_raw_error(rc) {
        Err(err)
    } else {
        Ok(())
    }
}

/// extern "C" WasmResult proxy_grpc_send(uint32_t token, const char* message_ptr, size_t message_size,
///                                       uint32_t end_stream);
/// TODO(docs)
///
/// ## Parameters
///
/// * `token` - TODO(docs)
/// * `message` - TODO(docs)
/// * `end_stream` - TODO(docs)
///
/// ## Return
///
/// * `error` - TODO(docs)
pub unsafe fn proxy_grpc_send(token: Token, message: &str, end_stream: Boolean) -> Result<()> {
    let rc = envoy::proxy_grpc_send(token, message.as_ptr(), message.len(), end_stream);
    if let Some(err) = Error::from_raw_error(rc) {
        Err(err)
    } else {
        Ok(())
    }
}

pub mod envoy {
    use super::*;
    #[link(wasm_import_module = "env")]
    extern "C" {
        /// Configuration and Status.
        /// extern "C" WasmResult proxy_get_configuration(const char** configuration_ptr,
        ///                                               size_t* configuration_size);
        /// TODO(docs)
        pub fn proxy_get_configuration(config: *mut *mut u8, config_len: *mut Size) -> WasmResult;
        /// extern "C" WasmResult proxy_get_status(uint32_t* status_code_ptr, const char** message_ptr,
        ///                                        size_t* message_size);
        /// Results status details for any previous ABI call and onGrpcClose.
        pub fn proxy_get_status(
            code: *mut WasmResult,
            message: *mut *mut u8,
            message_len: *mut Size,
        ) -> WasmResult;
        /// Logging
        /// extern "C" WasmResult proxy_log(LogLevel level, const char* logMessage, size_t messageSize);
        /// TODO(docs)
        pub fn proxy_log(level: LogLevel, message_ptr: *const u8, message_len: usize)
            -> WasmResult;
        /// Timer
        /// extern "C" WasmResult proxy_set_tick_period_milliseconds(uint32_t millisecond);
        /// Timer (must be called from a root context, e.g. onStart, onTick).
        pub fn proxy_set_tick_period_milliseconds(period_millis: u32) -> WasmResult;
        /// Time
        /// extern "C" WasmResult proxy_get_current_time_nanoseconds(uint64_t* nanoseconds);
        /// TODO(docs)
        pub fn proxy_get_current_time_nanoseconds(time: *mut Timestamp) -> WasmResult;
        /// State accessors
        /// extern "C" WasmResult proxy_get_property(const char* path_ptr, size_t path_size,
        ///                                          const char** value_ptr_ptr, size_t* value_size_ptr);
        /// TODO(docs)
        pub fn proxy_get_property(
            path_ptr: *const u8,
            path_len: usize,
            value: *mut *mut u8,
            value_len: *mut Size,
        ) -> WasmResult;
        /// extern "C" WasmResult proxy_set_property(const char* path_ptr, size_t path_size,
        ///                                          const char* value_ptr, size_t value_size);
        /// TODO(docs)
        pub fn proxy_set_property(
            path_ptr: *const u8,
            path_len: usize,
            value_ptr: *const u8,
            value_len: usize,
        ) -> WasmResult;
        /// System
        /// extern "C" WasmResult proxy_set_effective_context(uint32_t effective_context_id);
        /// TODO(docs)
        pub fn proxy_set_effective_context(id: ContextId) -> WasmResult;
        /// extern "C" WasmResult proxy_done();
        /// TODO(docs)
        pub fn proxy_done() -> WasmResult;
        /// Metrics
        /// extern "C" WasmResult proxy_define_metric(MetricType type, const char* name_ptr, size_t name_size,
        ///                                           uint32_t* metric_id);
        /// TODO(docs)
        pub fn proxy_define_metric(
            metric_type: MetricType,
            name_ptr: *const u8,
            name_len: usize,
            id: *mut MetricId,
        ) -> WasmResult;
        /// extern "C" WasmResult proxy_increment_metric(uint32_t metric_id, int64_t offset);
        /// TODO(docs)
        pub fn proxy_increment_metric(id: MetricId, offset: i64) -> WasmResult;
        /// extern "C" WasmResult proxy_record_metric(uint32_t metric_id, uint64_t value);
        /// TODO(docs)
        pub fn proxy_record_metric(id: MetricId, value: u64) -> WasmResult;
        /// extern "C" WasmResult proxy_get_metric(uint32_t metric_id, uint64_t* result);
        /// TODO(docs)
        pub fn proxy_get_metric(id: MetricId, value: *mut u64) -> WasmResult;
        /// Continue/Reply/Route
        /// extern "C" WasmResult proxy_continue_request();
        /// TODO(docs)
        pub fn proxy_continue_request() -> WasmResult;
        /// extern "C" WasmResult proxy_continue_response();
        /// TODO(docs)
        pub fn proxy_continue_response() -> WasmResult;
        /// extern "C" WasmResult
        /// proxy_send_local_response(uint32_t response_code, const char* response_code_details_ptr,
        ///                           size_t response_code_details_size, const char* body_ptr, size_t body_size,
        ///                           const char* additional_response_header_pairs_ptr,
        ///                           size_t additional_response_header_pairs_size, uint32_t grpc_status);
        /// TODO(docs)
        pub fn proxy_send_local_response(
            response_code: u32,
            response_code_details_ptr: *const u8,
            response_code_details_len: usize,
            body_ptr: *const u8,
            body_len: usize,
            additional_response_header_pairs_ptr: *const u8,
            additional_response_header_pairs_len: usize,
            grpc_status: GrpcStatus,
        ) -> WasmResult;
        /// extern "C" WasmResult proxy_clear_route_cache();
        /// TODO(docs)
        pub fn proxy_clear_route_cache() -> WasmResult;
        /// SharedData
        /// extern "C" WasmResult proxy_get_shared_data(const char* key_ptr, size_t key_size,
        ///                                             const char** value_ptr, size_t* value_size,
        ///                                             uint32_t* cas);
        /// Returns: Ok, NotFound
        /// TODO(docs)
        pub fn proxy_get_shared_data(
            key_ptr: *const u8,
            key_len: usize,
            value: *mut *mut u8,
            value_len: *mut Size,
            cas: *mut u32,
        ) -> WasmResult;
        /// extern "C" WasmResult proxy_set_shared_data(const char* key_ptr, size_t key_size,
        ///                                             const char* value_ptr, size_t value_size, uint32_t cas);
        /// //  If cas != 0 and cas != the current cas for 'key' return false, otherwise set the value and
        /// //  return true.
        /// // Returns: Ok, CasMismatch
        /// TODO(docs)
        pub fn proxy_set_shared_data(
            key_ptr: *const u8,
            key_len: usize,
            value_ptr: *const u8,
            value_len: usize,
            cas: u32,
        ) -> WasmResult;
        /// SharedQueue
        /// extern "C" WasmResult proxy_register_shared_queue(const char* queue_name_ptr,
        ///                                                   size_t queue_name_size, uint32_t* token);
        /// // Note: Registering the same queue_name will overwrite the old registration while preseving any
        /// // pending data. Consequently it should typically be followed by a call to
        /// // proxy_dequeue_shared_queue. Returns: Ok
        /// TODO(docs)
        pub fn proxy_register_shared_queue(
            queue_name_ptr: *const u8,
            queue_name_len: usize,
            token: *mut Token,
        ) -> WasmResult;
        /// extern "C" WasmResult proxy_resolve_shared_queue(const char* vm_id, size_t vm_id_size,
        ///                                                  const char* queue_name_ptr, size_t queue_name_size,
        ///                                                  uint32_t* token);
        /// // Returns: Ok, NotFound
        /// TODO(docs)
        pub fn proxy_resolve_shared_queue(
            vm_id_ptr: *const u8,
            vm_id_len: usize,
            queue_name_ptr: *const u8,
            queue_name_len: usize,
            token: *mut Token,
        ) -> WasmResult;
        /// extern "C" WasmResult proxy_dequeue_shared_queue(uint32_t token, const char** data_ptr,
        ///                                                  size_t* data_size);
        /// // Returns Ok, Empty, NotFound (token not registered).
        /// TODO(docs)
        pub fn proxy_dequeue_shared_queue(
            token: Token,
            data: *mut *mut u8,
            data_len: *mut Size,
        ) -> WasmResult;
        /// extern "C" WasmResult proxy_enqueue_shared_queue(uint32_t token, const char* data_ptr,
        ///                                                  size_t data_size);
        /// // Returns false if the queue was not found and the data was not enqueued.
        /// TODO(docs)
        pub fn proxy_enqueue_shared_queue(
            token: Token,
            data_ptr: *const u8,
            data_len: usize,
        ) -> WasmResult;
        /// Headers/Trailers/Metadata Maps
        /// extern "C" WasmResult proxy_add_header_map_value(HeaderMapType type, const char* key_ptr,
        ///                                                  size_t key_size, const char* value_ptr,
        ///                                                  size_t value_size);
        /// TODO(docs)
        pub fn proxy_add_header_map_value(
            headers_type: HeadersType,
            key_ptr: *const u8,
            key_len: usize,
            value_ptr: *const u8,
            value_len: usize,
        ) -> WasmResult;
        /// extern "C" WasmResult proxy_get_header_map_value(HeaderMapType type, const char* key_ptr,
        ///                                                  size_t key_size, const char** value_ptr,
        ///                                                  size_t* value_size);
        /// TODO(docs)
        pub fn proxy_get_header_map_value(
            headers_type: HeadersType,
            key_ptr: *const u8,
            key_len: usize,
            value: *mut *mut u8,
            value_len: *mut Size,
        ) -> WasmResult;
        /// extern "C" WasmResult proxy_get_header_map_pairs(HeaderMapType type, const char** ptr,
        ///                                                  size_t* size);
        /// TODO(docs)
        pub fn proxy_get_header_map_pairs(
            headers_type: HeadersType,
            buf: *mut *mut u8,
            buf_len: *mut Size,
        ) -> WasmResult;
        /// extern "C" WasmResult proxy_set_header_map_pairs(HeaderMapType type, const char* ptr, size_t size);
        /// TODO(docs)
        pub fn proxy_set_header_map_pairs(
            headers_type: HeadersType,
            buf_ptr: *const u8,
            buf_len: usize,
        ) -> WasmResult;
        /// extern "C" WasmResult proxy_replace_header_map_value(HeaderMapType type, const char* key_ptr,
        ///                                                      size_t key_size, const char* value_ptr,
        ///                                                      size_t value_size);
        /// TODO(docs)
        pub fn proxy_replace_header_map_value(
            headers_type: HeadersType,
            key_ptr: *const u8,
            key_len: usize,
            value_ptr: *const u8,
            value_len: usize,
        ) -> WasmResult;
        /// extern "C" WasmResult proxy_remove_header_map_value(HeaderMapType type, const char* key_ptr,
        ///                                                     size_t key_size);
        /// TODO(docs)
        pub fn proxy_remove_header_map_value(
            headers_type: HeadersType,
            key_ptr: *const u8,
            key_len: usize,
        ) -> WasmResult;
        /// extern "C" WasmResult proxy_get_header_map_size(HeaderMapType type, size_t* size);
        /// TODO(docs)
        pub fn proxy_get_header_map_size(
            headers_type: HeadersType,
            len: *mut MapSize,
        ) -> WasmResult;
        /// Buffer
        /// extern "C" WasmResult proxy_get_buffer_bytes(BufferType type, uint32_t start, uint32_t length,
        ///                                              const char** ptr, size_t* size);
        /// TODO(docs)
        pub fn proxy_get_buffer_bytes(
            buffer_type: BufferType,
            start: u32,
            length: u32,
            buf: *mut *mut u8,
            buf_len: *mut Size,
        ) -> WasmResult;
        /// extern "C" WasmResult proxy_get_buffer_status(BufferType type, size_t* length_ptr,
        ///                                               uint32_t* flags_ptr);
        /// TODO(docs)
        pub fn proxy_get_buffer_status(
            buffer_type: BufferType,
            len: *mut u32,
            flags: *mut BufferFlags,
        ) -> WasmResult;
        /// HTTP
        /// extern "C" WasmResult proxy_http_call(const char* uri_ptr, size_t uri_size, void* header_pairs_ptr,
        ///                                       size_t header_pairs_size, const char* body_ptr,
        ///                                       size_t body_size, void* trailer_pairs_ptr,
        ///                                       size_t trailer_pairs_size, uint32_t timeout_milliseconds,
        ///                                       uint32_t* token_ptr);
        /// TODO(docs)
        pub fn proxy_http_call(
            uri_ptr: *const u8,
            uri_len: usize,
            header_pairs_ptr: *const u8,
            header_pairs_len: usize,
            body_ptr: *const u8,
            body_len: usize,
            trailer_pairs_ptr: *const u8,
            trailer_pairs_len: usize,
            timeout_ms: u32,
            token: *mut Token,
        ) -> WasmResult;
        /// gRPC
        /// extern "C" WasmResult proxy_grpc_call(const char* service_ptr, size_t service_size,
        ///                                       const char* service_name_ptr, size_t service_name_size,
        ///                                       const char* method_name_ptr, size_t method_name_size,
        ///                                       const char* request_ptr, size_t request_size,
        ///                                       uint32_t timeout_milliseconds, uint32_t* token_ptr);
        /// TODO(docs)
        pub fn proxy_grpc_call(
            service_ptr: *const u8,
            service_len: usize,
            service_name_ptr: *const u8,
            service_name_len: usize,
            method_name_ptr: *const u8,
            method_name_len: usize,
            request_ptr: *const u8,
            request_len: usize,
            timeout_ms: u32,
            token: *mut Token,
        ) -> WasmResult;
        /// extern "C" WasmResult proxy_grpc_stream(const char* service_ptr, size_t service_size,
        ///                                         const char* service_name_ptr, size_t service_name_size,
        ///                                         const char* method_name_ptr, size_t method_name_size,
        ///                                         uint32_t* token_ptr);
        /// TODO(docs)
        pub fn proxy_grpc_stream(
            service_ptr: *const u8,
            service_len: usize,
            service_name_ptr: *const u8,
            service_name_len: usize,
            method_name_ptr: *const u8,
            method_name_len: usize,
            token: *mut Token,
        ) -> WasmResult;
        /// extern "C" WasmResult proxy_grpc_cancel(uint32_t token);
        /// TODO(docs)
        pub fn proxy_grpc_cancel(token: Token) -> WasmResult;
        /// extern "C" WasmResult proxy_grpc_close(uint32_t token);
        /// TODO(docs)
        pub fn proxy_grpc_close(token: Token) -> WasmResult;
        /// extern "C" WasmResult proxy_grpc_send(uint32_t token, const char* message_ptr, size_t message_size,
        ///                                       uint32_t end_stream);
        /// TODO(docs)
        pub fn proxy_grpc_send(
            token: Token,
            message_ptr: *const u8,
            message_len: usize,
            end_stream: Boolean,
        ) -> WasmResult;
    }
}
