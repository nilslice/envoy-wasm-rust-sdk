// This file is automatically generated, DO NOT EDIT
//
// To regenerate this file run the `crates/generate-raw` command (see https://github.com/bytecodealliance/wasi)

use core::mem::MaybeUninit;

pub use crate::error::Error;
pub type Result<T, E = Error> = core::result::Result<T, E>;
pub type WasmResult = u32;
/// No error occurred. ABI call completed successfully.
pub const WASM_RESULT_OK: WasmResult = 0;
/// The result could not be found, e.g. a provided key did not appear in a table.
pub const WASM_RESULT_NOT_FOUND: WasmResult = 1;
/// An argument was bad, e.g. did not conform to the required range.
pub const WASM_RESULT_BAD_ARGUMENT: WasmResult = 2;
/// A protobuf could not be serialized.
pub const WASM_RESULT_SERIALIZATION_FAILURE: WasmResult = 3;
/// A protobuf could not be parsed.
pub const WASM_RESULT_PARSE_FAILURE: WasmResult = 4;
/// A provided expression (e.g. "foo.bar") was illegal or unrecognized.
pub const WASM_RESULT_BAD_EXPRESSION: WasmResult = 5;
/// A provided memory range was not legal.
pub const WASM_RESULT_INVALID_MEMORY_ACCESS: WasmResult = 6;
/// Data was requested from an empty container.
pub const WASM_RESULT_EMPTY: WasmResult = 7;
/// The provided CAS did not match that of the stored data.
pub const WASM_RESULT_CAS_MISMATCH: WasmResult = 8;
/// Returned result was unexpected, e.g. of the incorrect size.
pub const WASM_RESULT_RESULT_MISMATCH: WasmResult = 9;
/// Internal failure: trying check logs of the surrounding system.
pub const WASM_RESULT_INTERNAL_FAILURE: WasmResult = 10;
/// The connection/stream/pipe was broken/closed unexpectedly.
pub const WASM_RESULT_BROKEN_CONNECTION: WasmResult = 11;
pub type PeerType = u32;
/// Unknown.
pub const PEER_TYPE_UNKNOWN: PeerType = 0;
/// Local.
pub const PEER_TYPE_LOCAL: PeerType = 1;
/// Remote.
pub const PEER_TYPE_REMOTE: PeerType = 2;
pub type FilterStatus = u32;
/// Continue to further filters.
pub const FILTER_STATUS_CONTINUE: FilterStatus = 0;
/// Stop executing further filters.
pub const FILTER_STATUS_STOP_ITERATION: FilterStatus = 1;
pub type FilterHeadersStatus = u32;
/// Continue filter chain iteration.
pub const FILTER_HEADERS_STATUS_CONTINUE: FilterHeadersStatus = 0;
/// Do not iterate to any of the remaining filters in the chain. Returning
/// FilterDataStatus::Continue from decodeData()/encodeData() or calling
/// continueDecoding()/continueEncoding() MUST be called if continued filter iteration is desired.
pub const FILTER_HEADERS_STATUS_STOP_ITERATION: FilterHeadersStatus = 1;
pub type FilterDataStatus = u32;
/// Continue filter chain iteration. If headers have not yet been sent to the next filter, they
/// will be sent first via decodeHeaders()/encodeHeaders(). If data has previously been buffered,
/// the data in this callback will be added to the buffer before the entirety is sent to the next
/// filter.
pub const FILTER_DATA_STATUS_CONTINUE: FilterDataStatus = 0;
/// Do not iterate to any of the remaining filters in the chain, and buffer body data for later
/// dispatching. Returning FilterDataStatus::Continue from decodeData()/encodeData() or calling
/// continueDecoding()/continueEncoding() MUST be called if continued filter iteration is desired.
///
/// This should be called by filters which must parse a larger block of the incoming data before
/// continuing processing and so can not push back on streaming data via watermarks.
///
/// If buffering the request causes buffered data to exceed the configured buffer limit, a 413 will
/// be sent to the user. On the response path exceeding buffer limits will result in a 500.
pub const FILTER_DATA_STATUS_STOP_ITERATION_AND_BUFFER: FilterDataStatus = 1;
/// Do not iterate to any of the remaining filters in the chain, and buffer body data for later
/// dispatching. Returning FilterDataStatus::Continue from decodeData()/encodeData() or calling
/// continueDecoding()/continueEncoding() MUST be called if continued filter iteration is desired.
///
/// This will cause the flow of incoming data to cease until one of the continue.*() functions is
/// called.
///
/// This should be returned by filters which can nominally stream data but have a transient back-up
/// such as the configured delay of the fault filter, or if the router filter is still fetching an
/// upstream connection.
pub const FILTER_DATA_STATUS_STOP_ITERATION_AND_WATERMARK: FilterDataStatus = 2;
/// Do not iterate to any of the remaining filters in the chain, but do not buffer any of the
/// body data for later dispatching. Returning FilterDataStatus::Continue from
/// decodeData()/encodeData() or calling continueDecoding()/continueEncoding() MUST be called if
/// continued filter iteration is desired.
pub const FILTER_DATA_STATUS_STOP_ITERATION_NO_BUFFER: FilterDataStatus = 3;
pub type FilterTrailersStatus = u32;
/// Continue filter chain iteration.
pub const FILTER_TRAILERS_STATUS_CONTINUE: FilterTrailersStatus = 0;
/// Do not iterate to any of the remaining filters in the chain. Calling
/// continueDecoding()/continueEncoding() MUST be called if continued filter iteration is desired.
pub const FILTER_TRAILERS_STATUS_STOP_ITERATION: FilterTrailersStatus = 1;
pub type FilterMetadataStatus = u32;
/// Continue filter chain iteration.
pub const FILTER_METADATA_STATUS_CONTINUE: FilterMetadataStatus = 0;
pub type HeadersType = u32;
/// Request headers of a proxied HTTP request.
pub const HEADERS_TYPE_REQUEST_HEADERS: HeadersType = 0;
/// Request trailers of a proxied HTTP request.
pub const HEADERS_TYPE_REQUEST_TRAILERS: HeadersType = 1;
/// Response headers of a proxied HTTP request.
pub const HEADERS_TYPE_RESPONSE_HEADERS: HeadersType = 2;
/// Response trailers of a proxied HTTP request.
pub const HEADERS_TYPE_RESPONSE_TRAILERS: HeadersType = 3;
/// Client's initial metadata of an outgoing gRPC call.
pub const HEADERS_TYPE_GRPC_CREATE_INITIAL_METADATA: HeadersType = 4;
/// Server's initial metadata of an outgoing gRPC call.
pub const HEADERS_TYPE_GRPC_RECEIVE_INITIAL_METADATA: HeadersType = 5;
/// Server's trailing metadata of an outgoing gRPC call.
pub const HEADERS_TYPE_GRPC_RECEIVE_TRAILING_METADATA: HeadersType = 6;
/// Response headers of an outgoing HTTP request.
pub const HEADERS_TYPE_HTTP_CALL_RESPONSE_HEADERS: HeadersType = 7;
/// Response trailers of an outgoing HTTP request.
pub const HEADERS_TYPE_HTTP_CALL_RESPONSE_TRAILERS: HeadersType = 8;
pub type BufferType = u32;
/// Request body of a proxied HTTP request.
pub const BUFFER_TYPE_HTTP_REQUEST_BODY: BufferType = 0;
/// Response body of a proxied HTTP request.
pub const BUFFER_TYPE_HTTP_RESPONSE_BODY: BufferType = 1;
/// Request payload of a proxied L4 connection.
pub const BUFFER_TYPE_NETWORK_DOWNSTREAM_DATA: BufferType = 2;
/// Response payload of a proxied L4 connection.
pub const BUFFER_TYPE_NETWORK_UPSTREAM_DATA: BufferType = 3;
/// Response body of an outgoing HTTP request.
pub const BUFFER_TYPE_HTTP_CALL_RESPONSE_BODY: BufferType = 4;
/// Response payload of an outgoing gRPC call.
pub const BUFFER_TYPE_GRPC_RECEIVE_BUFFER: BufferType = 5;
pub type BufferFlags = u32;
/// End of stream has been reached.
pub const BUFFER_FLAGS_END_OF_STREAM: BufferFlags = 0x1;
pub type Size = usize;
pub type MapSize = u32;
pub type ContextId = u32;
pub type Token = u32;
pub type MetricId = u32;
pub type MetricType = u32;
/// Counter.
pub const METRIC_TYPE_COUNTER: MetricType = 0;
/// Gauge.
pub const METRIC_TYPE_GAUGE: MetricType = 1;
/// Histogram.
pub const METRIC_TYPE_HISTOGRAM: MetricType = 2;
pub type Boolean = u32;
pub type Timestamp = u64;
pub type GrpcStatus = i32;
/// The RPC completed successfully.
pub const GRPC_STATUS_OK: GrpcStatus = 0;
/// The RPC was canceled.
pub const GRPC_STATUS_CANCELED: GrpcStatus = 1;
/// Some unknown error occurred.
pub const GRPC_STATUS_UNKNOWN: GrpcStatus = 2;
/// An argument to the RPC was invalid.
pub const GRPC_STATUS_INVALID_ARGUMENT: GrpcStatus = 3;
/// The deadline for the RPC expired before the RPC completed.
pub const GRPC_STATUS_DEADLINE_EXCEEDED: GrpcStatus = 4;
/// Some resource for the RPC was not found.
pub const GRPC_STATUS_NOT_FOUND: GrpcStatus = 5;
/// A resource the RPC attempted to create already exists.
pub const GRPC_STATUS_ALREADY_EXISTS: GrpcStatus = 6;
/// Permission was denied for the RPC.
pub const GRPC_STATUS_PERMISSION_DENIED: GrpcStatus = 7;
/// Some resource is exhausted, resulting in RPC failure.
pub const GRPC_STATUS_RESOURCE_EXHAUSTED: GrpcStatus = 8;
/// Some precondition for the RPC failed.
pub const GRPC_STATUS_FAILED_PRECONDITION: GrpcStatus = 9;
/// The RPC was aborted.
pub const GRPC_STATUS_ABORTED: GrpcStatus = 10;
/// Some operation was requested outside of a legal range.
pub const GRPC_STATUS_OUT_OF_RANGE: GrpcStatus = 11;
/// The RPC requested was not implemented.
pub const GRPC_STATUS_UNIMPLEMENTED: GrpcStatus = 12;
/// Some internal error occurred.
pub const GRPC_STATUS_INTERNAL: GrpcStatus = 13;
/// The RPC endpoint is current unavailable.
pub const GRPC_STATUS_UNAVAILABLE: GrpcStatus = 14;
/// There was some data loss resulting in RPC failure.
pub const GRPC_STATUS_DATA_LOSS: GrpcStatus = 15;
/// The RPC does not have required credentials for the RPC to succeed.
pub const GRPC_STATUS_UNAUTHENTICATED: GrpcStatus = 16;
/// This is a non-GRPC error code, indicating the status code in gRPC headers
/// was invalid.
pub const GRPC_STATUS_INVALID_CODE: GrpcStatus = -1;
pub type LogLevel = u32;
/// Trace.
pub const LOG_LEVEL_TRACE: LogLevel = 0;
/// Debug.
pub const LOG_LEVEL_DEBUG: LogLevel = 1;
/// Info.
pub const LOG_LEVEL_INFO: LogLevel = 2;
/// Warn.
pub const LOG_LEVEL_WARN: LogLevel = 3;
/// Error.
pub const LOG_LEVEL_ERROR: LogLevel = 4;
/// Critical.
pub const LOG_LEVEL_CRITICAL: LogLevel = 5;
